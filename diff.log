diff --git a/a.out b/a.out
index 2d66f20..355e992 100755
Binary files a/a.out and b/a.out differ
diff --git a/header.h b/header.h
index da35482..e35495c 100644
--- a/header.h
+++ b/header.h
@@ -8,19 +8,20 @@
 #include <sys/time.h>
 #include <sys/stat.h>
 #include <pthread.h>
+#include <float.h>
 
 /* macro variable */
 #define INIT 0
-#define TSPMAXSIZE 2000
-
 #define ON 1
 #define OFF 0
 #define YES ON
 #define NO OFF
 #define CHECK -1
 #define READONLY -2
+#define DEFAULT 0
 
 /* macro parameter */
+#define TSPMAXSIZE 2000
 #define DEFAULT_PERMITWORSE 50
 #define DEFAULT_SEARCHTIME 10
 
diff --git a/initial_path.c b/initial_path.c
index ff8c45f..cf0a61c 100644
--- a/initial_path.c
+++ b/initial_path.c
@@ -3,30 +3,123 @@
 
 /* functions */
 int * initial_euclid_path(int * euclid_data);
-int * initial_graph_path(double * graph_data);
+int * create_euclid_path(int * return_data, int * base_data, int create_mode);
+double * initial_graph_path(double * graph_data);
+double * create_graph_path(double * path, int create_mode);
+int random_num(int maximum);
+double make_distance(int x1, int y1, int x2, int y2);
+int already_visited(int * return_data, int city_num);
 int search_loop_times(int type);
 int * mallocer_ip(int size);
+double * mallocer_dp(int size);
+
+/* global variable */
+int create_mode = DEFAULT;
 
 int * initial_euclid_path(int * euclid_data)
 {
     int * return_data;
 
-    /* first time procedure */
+    /* first time procedure (mainly, alocate memory) */
     if(search_loop_times(READONLY) == 0) {
-        return_data = mallocer_ip(euclid_data[0]);
+        /* +10 is for something parameter */
+        return_data = mallocer_ip(euclid_data[0] + 10);
+        srand(time(NULL));
+        /* set return_data[0] to 'TSP-example-size' */
+        return_data[0] = euclid_data[0];
     }
 
+    /* create the initial path */
+    return_data = create_euclid_path(return_data, euclid_data, create_mode);
+
     return return_data;
 }
 
-int * initial_graph_path(double * graph_data)
+double * initial_graph_path(double * graph_data)
 {
-    int * return_data;
+    double * return_data;
 
     /* first time procedure */
     if(search_loop_times(READONLY) == 0) {
-        return_data = mallocer_ip(graph_data[0]);
+        return_data = mallocer_dp((int)graph_data[0]);
     }
 
+    /* create the initial path */
+    return_data = create_graph_path(return_data, create_mode);
+
     return return_data;
 }
+
+/* This fucntion makes 'initial-path' that type is 'Euclid' */
+int * create_euclid_path(int * return_data, int * euclid_data, int create_mode)
+{
+    int return_data_index;
+    int next_city;
+    int min_index;
+    int tsp_size = euclid_data[0];
+    int first_point;
+    int now_x, now_y;
+    int next_x, next_y;
+    double distance = DBL_MAX;
+    double min_distance = DBL_MAX;
+
+    /* Mode DEFAULT (nearest nearby) */
+    if(create_mode == DEFAULT) {
+        /* get first point by random (1 <= first_point <= tsp_size) */
+        first_point = random_num(tsp_size);
+
+        return_data[1] = first_point;
+        now_x = euclid_data[first_point * 2];
+        now_y = euclid_data[first_point * 2 + 1];
+
+        for(return_data_index = 2; return_data_index <= tsp_size; return_data_index++) {
+            for(next_city = 1; next_city <= tsp_size; next_city++) {
+                /* check already choiced cities */
+                if(already_visited(return_data, next_city) == YES) {
+                    continue;
+                }
+                else {
+                    next_x = euclid_data[next_city * 2];
+                    next_y = euclid_data[next_city * 2 + 1];
+                    distance = make_distance(now_x, now_y, next_x, next_y);
+                    if(min_distance > distance) {
+                        min_index = next_city;
+                        min_distance = distance;
+                    }
+                }
+                /* set the city of nearest at now-city */
+                return_data[return_data_index] = next_city;
+            }
+        }
+    }
+    /* Mode another */
+    else {
+        /* Non-aveirable, yet */
+    }
+
+    return return_data;
+}
+
+double * create_graph_path(double * path, int create_mode)
+{
+    double * return_data;
+
+    printf("Mr.Tozaki would write here\n");
+
+    return return_data;
+}
+
+int already_visited(int * return_data, int city_num)
+{
+    int i;
+    int return_num = NO;
+
+    for(i = 1; i <= return_data[0]; i++) {
+        if(return_data[i] == city_num) {
+            return_num = YES;
+            break;
+        }
+    }
+
+    return return_num;
+}
diff --git a/main.c b/main.c
index 1ed0d64..7415aac 100644
--- a/main.c
+++ b/main.c
@@ -38,6 +38,7 @@ int main(int argc, char ** argv)
     int visual_arg; /* Please edit !! for Waki */
     pthread_t visual_thread;
     int * solution_path;
+    int test;
 
     /* comand-line short option check */
     option_checker(argc, argv);
diff --git a/math.c b/math.c
index 86fa39a..0bce14c 100644
--- a/math.c
+++ b/math.c
@@ -3,8 +3,21 @@
 
 /* functions */
 double make_distance(int x1, int y1, int x2, int y2);
+int random_num(int maximum);
 
 double make_distance(int x1, int y1, int x2, int y2)
 {
     return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0));
 }
+
+int random_num(int maximum)
+{
+    int return_data;
+
+    /* (1 <= return_data <= maximum) */
+    if((return_data = rand() % maximum) == 0) {
+        return_data = maximum;
+    }
+
+    return return_data;
+}
diff --git a/tags b/tags
index 828c5e8..5c1eb91 100644
--- a/tags
+++ b/tags
@@ -4,10 +4,15 @@
 !_TAG_PROGRAM_NAME	Exuberant Ctags	//
 !_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
 !_TAG_PROGRAM_VERSION	5.7	//
+already_visited	initial_path.c	/^int already_visited(int * return_data, int city_num)$/;"	f
+create_euclid_path	initial_path.c	/^int * create_euclid_path(int * return_data, int * euclid_data, int create_mode)$/;"	f
+create_graph_path	initial_path.c	/^double * create_graph_path(double * path, int create_mode)$/;"	f
+create_mode	initial_path.c	/^int create_mode = DEFAULT;$/;"	v
 error_procedure	error.c	/^void error_procedure(char * message)$/;"	f
 finalize	finalize.c	/^void finalize(void)$/;"	f
 help_document	argument.c	/^void help_document(char ** argv)$/;"	f
 initial_euclid_path	initial_path.c	/^int * initial_euclid_path(int * euclid_data)$/;"	f
+initial_graph_path	initial_path.c	/^double * initial_graph_path(double * graph_data)$/;"	f
 initial_parameter	parameter.c	/^void initial_parameter(int tsp_size)$/;"	f
 loop_terminate	terminate.c	/^int loop_terminate(void)$/;"	f
 main	main.c	/^int main(int argc, char ** argv)$/;"	f
@@ -21,6 +26,7 @@ option_checker	argument.c	/^void option_checker(int argc, char ** argv)$/;"	f
 parameter	parameter.c	/^struct parameter {$/;"	s	file:
 parameterp	parameter.c	/^struct parameter * parameterp;$/;"	v	typeref:struct:parameter
 permit_worse	parameter.c	/^    double permit_worse;        \/* Parcentage of permitting to choice toward worse *\/$/;"	m	struct:parameter	file:
+random_num	math.c	/^int random_num(int maximum)$/;"	f
 read_data	read_data.c	/^int * read_data(void)$/;"	f
 read_data_set	read_data.c	/^void read_data_set(char * tspfilename)$/;"	f
 readfilename	read_data.c	/^char * readfilename;$/;"	v
diff --git a/terminate.c b/terminate.c
index 6c1bf8d..e6b6ae6 100644
--- a/terminate.c
+++ b/terminate.c
@@ -34,10 +34,10 @@ int search_terminate(void)
         printf("Search is terminated by timer()\n");
         return_num = YES;
     }
-    else if(search_loop_times(CHECK) >= 3) {
+    /*else if(search_loop_times(CHECK) >= 3) {
         printf("Search is terminated by search_loop_times()\n");
         return_num = YES;
-    }
+    }*/
 
     return return_num;
 }
